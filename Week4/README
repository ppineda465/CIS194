-->foo is really called (.), and represents function composition.
-->"$":   sum (map sqrt [1..130])  equals  sum (map sqrt [1..130])
-->The “multi-argument” lambda abstraction
Prelude> (\x y z -> [x,2*y,3*z]) 5 6 3
[5,12,9]

--> fold
Input: foldr (+) 5 [1,2,3,4]
Output: 15

--> zipwith
zipWith' (+) [4,2,5,6] [2,6,2,3]
[6,8,7,9]

foobar :: [Integer] -> Integer
foobar []     = 0
foobar (x:xs)
  | x > 3     = (7*x + 2) + foobar xs
  | otherwise = foobar xs

--> much more idiomatic implementation of foobar:

  foobar' :: [Integer] -> Integer
  foobar' = sum . map (\x -> 7*x + 2) . filter (>3)
